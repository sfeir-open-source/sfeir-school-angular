<!-- .slide: class="with-code inconsolata" -->
# Setup Native Federation

Using Native Federation without an Angular library can be complex.<br/><br/>

Fortunately, an Angular library exists: __@angular-architects/native-federation__ <br/><br/>

```shell
npm i @angular-architects/native-federation -D
```
<!-- .element: class="big-code" -->

<br/><br/>

This library must be installed in both the shell application and the remote application.
<!-- .element: class="important" -->

##==##

<!-- .slide: class="with-code inconsolata" -->
# Define an application as remote

Once the package is installed in your application, new schematics are available.<br/><br/>
To define your application as a remote app, run the following command:<br/><br/>

```shell
ng g @angular-architects/native-federation:init --project angular-remote --port 4201 --type remote
```
<!-- .element: class="big-code" -->

##==##

<!-- .slide: class="with-code inconsolata" -->
# Define an application as host

Once the package is installed in your application, new schematics are available.<br/><br/>
To define your application as a host app, run the following command:<br/><br/>

```shell
ng g @angular-architects/native-federation:init --project angular-host --port 4200 --type host
```
<!-- .element: class="big-code" -->

##==##

# What do these schematics do?

The files generated by the schematics are as follows:<br/><br/>

- federation.config.js -> native federation configuration <br/><br/>
- bootstrap.ts -> application bootstrap file (content from main.ts) <br/><br/>
- main.ts -> modified file to initialize native federation and then bootstrap the application <br/><br/>
- manifest.json -> only for the host, declaration of remotes <br/><br/>


##==##

<!-- .slide: class="with-code inconsolata" -->
# The native federation configuration file

```typescript
const {
  withNativeFederation,
  shareAll,
} = require('@angular-architects/native-federation/config');

module.exports = withNativeFederation({
  name: 'angularRemote',

  exposes: {
    './Component': './projects/mfe1/src/app/app.component.ts',
  },

  shared: {
    ...shareAll({
      singleton: true,
      strictVersion: true,
      requiredVersion: 'auto',
    }),
  },

  skip: [
    'rxjs/ajax',
    'rxjs/fetch',
    'rxjs/testing',
    'rxjs/webSocket',
    // Add further packages you don't need at runtime
  ],
});
```
<!-- .element: class="medium-code" -->

##==##
<!-- .slide: class="with-code inconsolata" -->
# The Remotes declaration file

```json
{
  "remotes": {
    "angularRemote": "http://localhost:4201"
  }
}
```
<!-- .element: class="big-code" -->

##==##
<!-- .slide: class="with-code inconsolata" -->
# The different types of remotes

Remote modules can be of different types:

- component <br/><br/>
- standalone component <br/><br/>
- set of standalone routes <br/><br/>
- module

<br/><br/>

To load a module and what it exports, use the following function:<br/><br/>

```typescript
const component = await loadRemoteModule('angularRemote', './Component');
```
<!-- .element: class="big-code" -->
